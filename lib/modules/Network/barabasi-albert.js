/* Copyright 2017 Pascal Grafe - MIT License */
'use strict';

(function () {
  spimosimCore.modules.add('Network', {
    name: 'barabasi-albert',
    files: [ 'lib/modules/Network/barabasi-albert.js' ],
    depends: [],
    version: '1.0',
    author: 'Pascal Grafe',
    description: 'A network generated by the barabasi albert algorithm.',
    date: '2020-03-26'
  }, {
    parameters: [ 'n', 'm' ],
    calculateNetworkSize: function (settings) {
      return settings.network.n;
    },
    generateAdjacencyLists: function (settings) {
      var n = settings.n,
        m = settings.m,
        egdeCount = 0,
        neighbors,
        adjacencyLists = [],
        list = new Uint32Array(2 * (n - 1) * m),//The list will contains every node one time for every of its egdes
        len = 0;//The number of used entries of list.

      //Create a complete network of m nodes.
      for (var i = 0; i < m; i++) {
        neighbors = [];
        for (var j = 0; j < i; j++) {
          neighbors.push(j);
          list[len++] = j;//save that node j to list because it got a new egde
        }
        for (var j = i + 1; j < m; j++) {
          neighbors.push(j);
          list[len++] = j;//save that node j to list because it got a new egde
        }

        adjacencyLists.push(neighbors);
      }

      //Create n - m new nodes with m edges.
      for (var i = m; i < n; i++) {
        neighbors = [];

        for (var k = 0; k < m;) {
          var j = list[Math.floor(Math.random() * len)];//Select a node with an probability proportional to its existing nodes.


          if (j !== i && neighbors.indexOf(j) === -1) {
            neighbors.push(j);
            adjacencyLists[j].push(i);

            list[len++] = i;//save that node i to list because it got a new egde
            list[len++] = j;//save that node j to list because it got a new egde

            k++;//move on to next node
          }
        }

        adjacencyLists.push(neighbors);
      }

      return adjacencyLists;
    }
  });
}());
